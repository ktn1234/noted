SET
  statement_timeout = 0;

SET
  lock_timeout = 0;

SET
  idle_in_transaction_session_timeout = 0;

SET
  client_encoding = 'UTF8';

SET
  standard_conforming_strings = on;

SELECT
  pg_catalog.set_config ('search_path', '', false);

SET
  check_function_bodies = false;

SET
  xmloption = content;

SET
  client_min_messages = warning;

SET
  row_security = off;

CREATE EXTENSION IF NOT EXISTS "pg_net"
WITH
  SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgsodium";

COMMENT ON SCHEMA "public" IS 'standard public schema';

CREATE EXTENSION IF NOT EXISTS "pg_graphql"
WITH
  SCHEMA "graphql";

CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"
WITH
  SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgcrypto"
WITH
  SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgjwt"
WITH
  SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "supabase_vault"
WITH
  SCHEMA "vault";

CREATE EXTENSION IF NOT EXISTS "uuid-ossp"
WITH
  SCHEMA "extensions";

CREATE OR REPLACE FUNCTION "public"."handle_new_user" () RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $$
begin
    insert into public.profiles (
        user_id,
        username,
        full_name,
        avatar_url,
        website
    )
    values (
        new.id, 
        new.raw_user_meta_data ->> 'username', 
        new.raw_user_meta_data ->> 'full_name', 
        new.raw_user_meta_data ->> 'avatar_url',
        new.raw_user_meta_data ->> 'website'
    );
    return new;
end;
$$;

ALTER FUNCTION "public"."handle_new_user" () OWNER TO "postgres";

SET
  default_tablespace = '';

SET
  default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."notes" (
  "id" bigint NOT NULL,
  "user_id" "uuid" DEFAULT "auth"."uid" () NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now" () NOT NULL,
  "text" "text" NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now" () NOT NULL
);

ALTER TABLE "public"."notes" OWNER TO "postgres";

ALTER TABLE "public"."notes"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
  SEQUENCE NAME "public"."notes_id_seq" START
  WITH
    1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."notifications" (
  "id" bigint NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now" () NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now" (),
  "endpoint" "text",
  "user_id" "uuid" DEFAULT "auth"."uid" ()
);

ALTER TABLE "public"."notifications" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."profiles" (
  "updated_at" timestamp with time zone DEFAULT "now" () NOT NULL,
  "username" "text" NOT NULL,
  "full_name" "text",
  "avatar_url" "text",
  "website" "text",
  "created_at" timestamp with time zone DEFAULT "now" () NOT NULL,
  "user_id" "uuid" DEFAULT "auth"."uid" () NOT NULL,
  "id" bigint NOT NULL,
  CONSTRAINT "username_length" CHECK (("char_length" ("username") >= 3))
);

ALTER TABLE "public"."profiles" OWNER TO "postgres";

ALTER TABLE "public"."profiles"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
  SEQUENCE NAME "public"."profiles_id_seq" START
  WITH
    1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."reactions" (
  "id" bigint NOT NULL,
  "note_id" bigint NOT NULL,
  "user_id" "uuid" NOT NULL,
  "emoji" "text" NOT NULL
);

ALTER TABLE "public"."reactions" OWNER TO "postgres";

ALTER TABLE "public"."reactions"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
  SEQUENCE NAME "public"."reactions_id_seq" START
  WITH
    1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."subscriptions" (
  "id" bigint NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now" () NOT NULL,
  "subscriber_user_id" "uuid" DEFAULT "auth"."uid" () NOT NULL,
  "user_id" "uuid" DEFAULT "auth"."uid" () NOT NULL
);

ALTER TABLE "public"."subscriptions" OWNER TO "postgres";

ALTER TABLE "public"."notifications"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
  SEQUENCE NAME "public"."subscriptions_id_seq" START
  WITH
    1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

ALTER TABLE "public"."subscriptions"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
  SEQUENCE NAME "public"."subscriptions_id_seq1" START
  WITH
    1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

ALTER TABLE ONLY "public"."notes"
ADD CONSTRAINT "notes_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."profiles"
ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("user_id");

ALTER TABLE ONLY "public"."profiles"
ADD CONSTRAINT "profiles_username_key" UNIQUE ("username");

ALTER TABLE ONLY "public"."reactions"
ADD CONSTRAINT "reactions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."notifications"
ADD CONSTRAINT "subscriptions_endpoint_key" UNIQUE ("endpoint");

ALTER TABLE ONLY "public"."subscriptions"
ADD CONSTRAINT "subscriptions_id_key" UNIQUE ("id");

ALTER TABLE ONLY "public"."notifications"
ADD CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."subscriptions"
ADD CONSTRAINT "subscriptions_pkey1" PRIMARY KEY ("id", "subscriber_user_id", "user_id");

CREATE OR REPLACE TRIGGER "note-created"
AFTER INSERT ON "public"."notes" FOR EACH ROW
EXECUTE FUNCTION "supabase_functions"."http_request" (
  'https://qvtivjvkltrrwxbwwzwy.supabase.co/functions/v1/note-created-push-notification',
  'POST',
  '{"Content-type":"application/json","Authorization":"Bearer <service_role_key>"}',
  '{}',
  '1000'
);

ALTER TABLE ONLY "public"."notes"
ADD CONSTRAINT "notes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles" ("user_id");

ALTER TABLE ONLY "public"."profiles"
ADD CONSTRAINT "profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users" ("id");

ALTER TABLE ONLY "public"."reactions"
ADD CONSTRAINT "reactions_note_id_fkey" FOREIGN KEY ("note_id") REFERENCES "public"."notes" ("id");

ALTER TABLE ONLY "public"."reactions"
ADD CONSTRAINT "reactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles" ("user_id");

ALTER TABLE ONLY "public"."subscriptions"
ADD CONSTRAINT "subscriptions_subscriber_user_id_fkey" FOREIGN KEY ("subscriber_user_id") REFERENCES "public"."profiles" ("user_id");

ALTER TABLE ONLY "public"."subscriptions"
ADD CONSTRAINT "subscriptions_user_id_fkey1" FOREIGN KEY ("user_id") REFERENCES "public"."profiles" ("user_id");

CREATE POLICY " Authenticated Users can ENABLE app notifications" ON "public"."notifications" FOR INSERT TO "authenticated"
WITH
  CHECK (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Authenticated Users can CREATE notes" ON "public"."notes" FOR INSERT TO "authenticated"
WITH
  CHECK (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Authenticated Users can DELETE their user notifications" ON "public"."subscriptions" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT
        "auth"."uid" () AS "uid"
    ) = "subscriber_user_id"
  )
);

CREATE POLICY "Authenticated Users can DISABLE own app notifications" ON "public"."notifications" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT
        "auth"."uid" () AS "uid"
    ) = "user_id"
  )
);

CREATE POLICY "Authenticated Users can READ other Authenticated Users' Profile" ON "public"."profiles" FOR
SELECT
  TO "authenticated" USING (true);

CREATE POLICY "Authenticated Users can READ other Authenticated Users' notes" ON "public"."notes" FOR
SELECT
  TO "authenticated" USING (true);

CREATE POLICY "Authenticated Users can READ own app notifications" ON "public"."notifications" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Authenticated Users can READ their user notifications" ON "public"."subscriptions" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "subscriber_user_id"
    )
  );

CREATE POLICY "Authenticated Users can SUBSCRIBE for user notifications" ON "public"."subscriptions" FOR INSERT TO "authenticated"
WITH
  CHECK (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Authenticated Users can only DELETE notes they wrote" ON "public"."notes" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT
        "auth"."uid" () AS "uid"
    ) = "user_id"
  )
);

CREATE POLICY "Authenticated Users can only UPDATE notes they wrote" ON "public"."notes"
FOR UPDATE
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Authenticated Users can only UPDATE their own profile" ON "public"."profiles"
FOR UPDATE
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Authenticated Users can only UPSERT their own profile" ON "public"."profiles" FOR INSERT TO "authenticated"
WITH
  CHECK (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable delete for users based on user_id" ON "public"."reactions" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT
        "auth"."uid" () AS "uid"
    ) = "user_id"
  )
);

CREATE POLICY "Enable insert for authenticated users only" ON "public"."reactions" FOR INSERT TO "authenticated"
WITH
  CHECK (
    (
      (
        SELECT
          "auth"."uid" () AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable select for authenticated users only" ON "public"."reactions" FOR
SELECT
  TO "authenticated" USING (true);

ALTER TABLE "public"."notes" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."reactions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."subscriptions" ENABLE ROW LEVEL SECURITY;

ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "anon";

GRANT USAGE ON SCHEMA "public" TO "authenticated";

GRANT USAGE ON SCHEMA "public" TO "service_role";

SET SESSION AUTHORIZATION "postgres";

RESET SESSION AUTHORIZATION;

SET SESSION AUTHORIZATION "postgres";

RESET SESSION AUTHORIZATION;

SET SESSION AUTHORIZATION "postgres";

RESET SESSION AUTHORIZATION;

SET SESSION AUTHORIZATION "postgres";

RESET SESSION AUTHORIZATION;

SET SESSION AUTHORIZATION "postgres";

RESET SESSION AUTHORIZATION;

SET SESSION AUTHORIZATION "postgres";

RESET SESSION AUTHORIZATION;

GRANT ALL ON FUNCTION "public"."handle_new_user" () TO "anon";

GRANT ALL ON FUNCTION "public"."handle_new_user" () TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_new_user" () TO "service_role";

GRANT ALL ON TABLE "public"."notes" TO "anon";

GRANT ALL ON TABLE "public"."notes" TO "authenticated";

GRANT ALL ON TABLE "public"."notes" TO "service_role";

GRANT ALL ON SEQUENCE "public"."notes_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."notes_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."notes_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."notifications" TO "anon";

GRANT ALL ON TABLE "public"."notifications" TO "authenticated";

GRANT ALL ON TABLE "public"."notifications" TO "service_role";

GRANT ALL ON TABLE "public"."profiles" TO "anon";

GRANT ALL ON TABLE "public"."profiles" TO "authenticated";

GRANT ALL ON TABLE "public"."profiles" TO "service_role";

GRANT ALL ON SEQUENCE "public"."profiles_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."profiles_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."profiles_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."reactions" TO "anon";

GRANT ALL ON TABLE "public"."reactions" TO "authenticated";

GRANT ALL ON TABLE "public"."reactions" TO "service_role";

GRANT ALL ON SEQUENCE "public"."reactions_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."reactions_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."reactions_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."subscriptions" TO "anon";

GRANT ALL ON TABLE "public"."subscriptions" TO "authenticated";

GRANT ALL ON TABLE "public"."subscriptions" TO "service_role";

GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq" TO "service_role";

GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq1" TO "anon";

GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq1" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq1" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "service_role";

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users FOR EACH ROW
EXECUTE FUNCTION public.handle_new_user ();

create policy "Anyone can update their own avatar." on "storage"."objects" as permissive
for update
  to public using ((auth.uid () = owner))
with
  check ((bucket_id = 'avatars'::text));
